import { Router, Request, Response } from "express";
import { db } from "./db";
import { squadrons, squadronMembers, gamingPlayers, gamingNfts, inquisitionNftAudit } from "../shared/schema";
import { sessionAuth, requireAuthentication, requireAuthenticationReadOnly, AuthenticatedRequest } from "./middleware/session-auth";
import { eq, and, desc, sql } from "drizzle-orm";
import crypto from "crypto";
import { z } from "zod";

// ==========================================
// VALIDATION SCHEMAS
// ==========================================

const createSquadronSchema = z.object({
  name: z.string().min(1).max(100),
  description: z.string().max(500).optional(),
  squadron_type: z.enum(['offensive', 'defensive', 'balanced', 'support']).default('balanced'),
  nfts: z.array(z.object({
    nft_id: z.string(),
    nft_name: z.string(),
    nft_image: z.string().optional(),
    nft_power: z.number().optional(),
    position: z.number().optional()
  })).min(1).max(10),
  power: z.object({
    army: z.number(),
    religion: z.number(),
    civilization: z.number(),
    economic: z.number(),
    total: z.number()
  })
});

const createBattleSchema = z.object({
  battle_type: z.enum(['1v1', 'open', 'tournament', 'quick']).default('quick'),
  squadron_id: z.string().uuid(),
  opponent_handle: z.string().optional(),
  wager_type: z.enum(['xrp', 'rdl', 'none']).default('none'),
  wager_amount: z.union([z.string(), z.number()]).optional(),
  description: z.string().max(500).optional(),
  squadron_power: z.number().optional()
});

const router = Router();

// CREATE Squadron - Requires full authentication with session
router.post("/api/gaming/squadrons", requireAuthentication, async (req: AuthenticatedRequest, res: Response) => {
  try {
    console.log("ðŸŽ¯ [SQUADRON CREATE] Squadron creation request received");
    const userHandle = req.user?.handle || req.user?.userHandle;
    
    if (!userHandle) {
      console.error("âŒ [SQUADRON CREATE] No user handle in request");
      return res.status(401).json({ error: "Not authenticated" });
    }

    console.log("ðŸ‘¤ [SQUADRON CREATE] User:", userHandle);
    
    // Validate request body with Zod schema
    let validatedData;
    try {
      validatedData = createSquadronSchema.parse(req.body);
      console.log("âœ… [SQUADRON CREATE] Request data validated");
    } catch (validationError: any) {
      console.error("âŒ [SQUADRON CREATE] Validation failed:", validationError.errors);
      return res.status(400).json({ 
        error: "Invalid request data", 
        details: validationError.errors 
      });
    }

    const { name, description, squadron_type, nfts, power } = validatedData;
    console.log("ðŸ“ [SQUADRON CREATE] Request data:", { 
      name, 
      nftCount: nfts.length, 
      squadronType: squadron_type,
      totalPower: power.total
    });

    // Look up or auto-create gaming_players record
    let player = await db.query.gamingPlayers.findFirst({
      where: eq(gamingPlayers.user_handle, userHandle),
    });

    if (!player) {
      console.log("ðŸ‘¤ [SQUADRON] Auto-creating gaming player for:", userHandle);
      const walletAddress = req.user?.walletAddress || "unknown";
      const playerData = {
        user_handle: userHandle,
        wallet_address: walletAddress,
        chain: "xrpl",
        player_name: userHandle
      };
      const [newPlayer] = await db.insert(gamingPlayers).values(playerData as any as any).returning();
      player = newPlayer;
      console.log("âœ… [SQUADRON] Created gaming player:", player.id);
    }

    console.log("ðŸ†” [SQUADRON CREATE] Will use auto-generated squadron ID from schema");

    console.log("ðŸ’¾ [SQUADRON CREATE] Inserting squadron into database...");
    
    try {
      // Insert squadron with all required fields
      // Note: id, created_at, updated_at are auto-generated by schema defaults
      const squadronData = {
        player_id: player.id,
        name: name.trim(),
        description: description || null,
        squadron_type: squadron_type || "balanced",
        total_army_power: power.army.toString(),
        total_religion_power: power.religion.toString(),
        total_civilization_power: power.civilization.toString(),
        total_economic_power: power.economic.toString(),
        total_power: power.total.toString(),
        nft_count: nfts.length,
        max_nft_capacity: 10,
        is_active: true,
        in_battle: false,
        battles_won: 0,
        battles_lost: 0,
        total_xrp_won: "0"
      };
      const [insertedSquadron] = await db.insert(squadrons).values(squadronData as any as any).returning();
      
      console.log("âœ… [SQUADRON CREATE] Squadron inserted successfully:", {
        id: insertedSquadron.id,
        name: insertedSquadron.name,
        player_id: insertedSquadron.player_id
      });

      console.log("ðŸ‘¥ [SQUADRON CREATE] Adding", nfts.length, "NFT members...");
      const memberValues = nfts.map((nft: any, index: number) => ({
        // id and added_at are auto-generated by schema defaults
        squadron_id: insertedSquadron.id,
        nft_id: nft.nft_id,
        nft_name: nft.nft_name,
        nft_image: nft.nft_image,
        nft_power: nft.nft_power ? nft.nft_power.toString() : "0",
        position: nft.position !== undefined ? nft.position : index
      }));

      const insertedMembers = await db.insert(squadronMembers).values(memberValues as any as any).returning();
      console.log("âœ… [SQUADRON CREATE] All squadron members added successfully:", {
        count: insertedMembers.length,
        members: insertedMembers.map(m => ({ id: m.id, nft_name: m.nft_name }))
      });

      console.log("ðŸŽ‰ [SQUADRON CREATE] Squadron creation complete:", insertedSquadron.id);
      
      // Return complete squadron data for frontend display
      res.json({
        success: true,
        squadron: {
          id: insertedSquadron.id,
          player_id: insertedSquadron.player_id,
          name: insertedSquadron.name,
          description: insertedSquadron.description,
          squadron_type: insertedSquadron.squadron_type,
          total_army_power: insertedSquadron.total_army_power,
          total_religion_power: insertedSquadron.total_religion_power,
          total_civilization_power: insertedSquadron.total_civilization_power,
          total_economic_power: insertedSquadron.total_economic_power,
          total_power: insertedSquadron.total_power,
          nft_count: insertedSquadron.nft_count,
          max_nft_capacity: insertedSquadron.max_nft_capacity,
          is_active: insertedSquadron.is_active,
          in_battle: insertedSquadron.in_battle,
          battles_won: insertedSquadron.battles_won,
          battles_lost: insertedSquadron.battles_lost,
          created_at: insertedSquadron.created_at,
          updated_at: insertedSquadron.updated_at,
          members: insertedMembers.map((member) => ({
            id: member.id,
            squadron_id: member.squadron_id,
            nft_id: member.nft_id,
            nft_name: member.nft_name,
            nft_image: member.nft_image,
            nft_power: member.nft_power,
            position: member.position,
            added_at: member.added_at,
          })),
        },
      });
    } catch (dbError: any) {
      console.error("âŒ [SQUADRON CREATE] Database error:", {
        message: dbError.message,
        code: dbError.code,
        detail: dbError.detail,
        stack: dbError.stack
      });
      throw new Error(`Failed to save squadron to database: ${dbError.message}`);
    }
  } catch (error: any) {
    console.error("âŒ [SQUADRON CREATE] Error creating squadron:", error);
    console.error("âŒ [SQUADRON CREATE] Error stack:", error.stack);
    res.status(500).json({ error: error.message });
  }
});

// GET endpoint uses requireAuthentication - standard auth middleware
router.get("/api/gaming/squadrons", requireAuthenticationReadOnly, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const userHandle = req.user?.handle || req.user?.userHandle;
    
    if (!userHandle) {
      console.error("âŒ [GET SQUADRONS] No user handle in request");
      return res.status(401).json({ error: "Not authenticated" });
    }
    
    console.log("âœ… [GET SQUADRONS] Authenticated user:", userHandle);

    const player = await db.query.gamingPlayers.findFirst({
      where: eq(gamingPlayers.user_handle, userHandle),
    });

    if (!player) {
      return res.json({ 
        success: true,
        squadrons: [],
        count: 0
      });
    }

    const playerSquadrons = await db
      .select()
      .from(squadrons)
      .where(eq(squadrons.player_id, player.id))
      .orderBy(desc(squadrons.created_at));

    const squadronsWithMembers = await Promise.all(
      playerSquadrons.map(async (squadron) => {
        const members = await db
          .select()
          .from(squadronMembers)
          .where(eq(squadronMembers.squadron_id, squadron.id))
          .orderBy(squadronMembers.position);

        return {
          ...squadron,
          members,
        };
      })
    );

    res.json({ 
      success: true,
      squadrons: squadronsWithMembers,
      count: squadronsWithMembers.length
    });
  } catch (error: any) {
    console.error("Error fetching squadrons:", error);
    res.status(500).json({ error: error.message });
  }
});

// GET endpoint uses requireAuthentication - standard auth middleware
router.get("/api/squadrons/player", requireAuthenticationReadOnly, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const userHandle = req.user?.handle || req.user?.userHandle;
    
    if (!userHandle) {
      return res.status(401).json({ error: "Not authenticated" });
    }

    const player = await db.query.gamingPlayers.findFirst({
      where: eq(gamingPlayers.user_handle, userHandle),
    });

    if (!player) {
      return res.json({ 
        success: true,
        squadrons: [],
        count: 0
      });
    }

    const playerSquadrons = await db
      .select()
      .from(squadrons)
      .where(eq(squadrons.player_id, player.id))
      .orderBy(desc(squadrons.created_at));

    const squadronsWithMembers = await Promise.all(
      playerSquadrons.map(async (squadron) => {
        const members = await db
          .select()
          .from(squadronMembers)
          .where(eq(squadronMembers.squadron_id, squadron.id))
          .orderBy(squadronMembers.position);

        return {
          ...squadron,
          members,
        };
      })
    );

    res.json({ 
      success: true,
      squadrons: squadronsWithMembers,
      count: squadronsWithMembers.length
    });
  } catch (error: any) {
    console.error("Error fetching squadrons:", error);
    res.status(500).json({ error: error.message });
  }
});

// GET individual squadron with power calculations
router.get("/api/squadrons/:id", requireAuthenticationReadOnly, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { id } = req.params;
    const userHandle = req.user?.handle || req.user?.userHandle;
    
    if (!userHandle) {
      return res.status(401).json({ error: "Not authenticated" });
    }

    console.log(`ðŸ” [SQUADRON DETAIL] Fetching squadron ${id} for user ${userHandle}`);

    // Get squadron with owner verification
    const squadron = await db.query.squadrons.findFirst({
      where: eq(squadrons.id, id)
    });

    if (!squadron) {
      return res.status(404).json({ error: "Squadron not found" });
    }

    // Verify ownership
    const player = await db.query.gamingPlayers.findFirst({
      where: eq(gamingPlayers.user_handle, userHandle)
    });

    if (!player || squadron.player_id !== player.id) {
      return res.status(403).json({ error: "You don't have permission to view this squadron" });
    }

    // Get squadron members with NFT details
    const members = await db
      .select({
        id: squadronMembers.id,
        squadron_id: squadronMembers.squadron_id,
        nft_id: squadronMembers.nft_id,
        position: squadronMembers.position,
        joined_at: squadronMembers.added_at,
        nft_name: gamingNfts.name,
        nft_image: gamingNfts.image_url,
        army_power: inquisitionNftAudit.power_strength,
        religion_power: inquisitionNftAudit.power_magic,
        civilization_power: inquisitionNftAudit.power_defense,
        economic_power: inquisitionNftAudit.power_speed,
        total_power: sql`COALESCE(${inquisitionNftAudit.power_strength}, 0) + COALESCE(${inquisitionNftAudit.power_magic}, 0) + COALESCE(${inquisitionNftAudit.power_defense}, 0) + COALESCE(${inquisitionNftAudit.power_speed}, 0)`.as('total_power'),
      })
      .from(squadronMembers)
      .leftJoin(gamingNfts, eq(squadronMembers.nft_id, gamingNfts.id))
      .leftJoin(inquisitionNftAudit, eq(squadronMembers.nft_id, inquisitionNftAudit.nft_token_id))
      .where(eq(squadronMembers.squadron_id, id))
      .orderBy(squadronMembers.position);

    // Calculate total power
    const totalArmyPower = members.reduce((sum, m) => sum + (Number(m.army_power) || 0), 0);
    const totalReligionPower = members.reduce((sum, m) => sum + (Number(m.religion_power) || 0), 0);
    const totalCivilizationPower = members.reduce((sum, m) => sum + (Number(m.civilization_power) || 0), 0);
    const totalEconomicPower = members.reduce((sum, m) => sum + (Number(m.economic_power) || 0), 0);
    const totalPower = members.reduce((sum, m) => sum + (Number(m.total_power) || 0), 0);

    console.log(`âœ… [SQUADRON DETAIL] Squadron ${squadron.name}: ${members.length} members, ${totalPower} total power`);

    res.json({
      success: true,
      data: {
        ...squadron,
        members,
        total_army_power: totalArmyPower,
        total_religion_power: totalReligionPower,
        total_civilization_power: totalCivilizationPower,
        total_economic_power: totalEconomicPower,
        total_power: totalPower,
        nft_count: members.length
      }
    });
  } catch (error: any) {
    console.error("âŒ [SQUADRON DETAIL] Error:", error);
    res.status(500).json({ error: error.message });
  }
});

// CREATE Battle - Requires full authentication with session
router.post("/api/gaming/battles/create", requireAuthentication, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const userHandle = req.user?.handle || req.user?.userHandle;
    
    if (!userHandle) {
      console.error("âŒ [BATTLE CREATE] No user handle in request");
      return res.status(401).json({ error: "Not authenticated" });
    }

    console.log("ðŸŽ¯ [BATTLE CREATE] Battle creation request received from:", userHandle);
    
    // Validate request body with Zod schema
    let validatedData;
    try {
      validatedData = createBattleSchema.parse(req.body);
      console.log("âœ… [BATTLE CREATE] Request data validated");
    } catch (validationError: any) {
      console.error("âŒ [BATTLE CREATE] Validation failed:", validationError.errors);
      return res.status(400).json({ 
        error: "Invalid request data", 
        details: validationError.errors 
      });
    }

    const { battle_type, squadron_id, opponent_handle, wager_type, wager_amount, description, squadron_power } = validatedData;

    // Look up or auto-create gaming_players record
    let player = await db.query.gamingPlayers.findFirst({
      where: eq(gamingPlayers.user_handle, userHandle),
    });

    if (!player) {
      console.log("ðŸ‘¤ [SQUADRON] Auto-creating gaming player for:", userHandle);
      const walletAddress = req.user?.walletAddress || "unknown";
      const playerData = {
        user_handle: userHandle,
        wallet_address: walletAddress,
        chain: "xrpl",
        player_name: userHandle
      };
      const [newPlayer] = await db.insert(gamingPlayers).values(playerData as any as any).returning();
      player = newPlayer;
      console.log("âœ… [SQUADRON] Created gaming player:", player.id);
    }

    const squadron = await db.query.squadrons.findFirst({
      where: and(eq(squadrons.id, squadron_id), eq(squadrons.player_id, player.id)),
    });

    if (!squadron) {
      return res.status(404).json({ error: "Squadron not found or not owned by player" });
    }

    if (squadron.in_battle) {
      return res.status(400).json({ error: "Squadron is already in battle" });
    }

    const battleId = crypto.randomUUID();
    
    console.log("ðŸ’¾ [BATTLE CREATE] Creating battle in database...");
    
    // Import battles table if not already imported
    const { battles } = await import("../shared/schema");
    
    // Set expiration time (24 hours for open battles)
    const expiresAt = new Date();
    expiresAt.setHours(expiresAt.getHours() + 24);
    
    let newBattle;
    try {
      // Create battle record in database - id and created_at auto-generated
      [newBattle] = await db.insert(battles).values({
        battle_type: battle_type || 'quick',
        combat_type: 'military',
        land_type: 'plains',
  // Use the gaming player UUID (player.id as any) as the creator_player_id to match schema
  // and other code that compares by player.id
  creator_player_id: player.id,
        creator_squadron_id: squadron_id,
        wager_amount: wager_amount?.toString() || "0",
        status: opponent_handle ? 'open' : 'open',
        is_friendly: wager_amount === 0 || wager_amount === '0',
        response_timeout_minutes: 60,
        expires_at: expiresAt
      } as any).returning();
      
      console.log("âœ… [BATTLE CREATE] Battle created successfully:", {
        id: newBattle.id,
        type: newBattle.battle_type,
        creator: newBattle.creator_player_id
      });

      // Update squadron to mark it in battle
      const updatedSquadron = await db.update(squadrons)
        .set({
          in_battle: true,
          current_battle_id: newBattle.id
        } as any)
        .where(eq(squadrons.id, squadron_id))
        .returning();
      
      console.log("âœ… [BATTLE CREATE] Squadron locked for battle:", {
        squadron_id: updatedSquadron[0]?.id,
        in_battle: updatedSquadron[0]?.in_battle,
        battle_id: updatedSquadron[0]?.current_battle_id
      });
    } catch (dbError: any) {
      console.error("âŒ [BATTLE CREATE] Database error:", {
        message: dbError.message,
        code: dbError.code,
        detail: dbError.detail,
        stack: dbError.stack
      });
      throw new Error(`Failed to save battle to database: ${dbError.message}`);
    }

    // Return complete battle data for frontend display
    res.json({
      success: true,
      battle: {
        id: newBattle.id,
        battle_type: newBattle.battle_type,
        squadron_id: squadron_id,
        opponent_handle: opponent_handle || null,
        wager_type: wager_type,
        wager_amount: wager_amount?.toString() || "0",
        status: newBattle.status,
        created_at: newBattle.created_at,
        description: description || null,
        // Include squadron details for frontend
        squadron: {
          id: squadron.id,
          name: squadron.name,
          total_power: squadron.total_power,
          nft_count: squadron.nft_count,
        },
      },
      message: battle_type === '1v1' 
        ? `Battle challenge sent to ${opponent_handle}!`
        : "Open battle created successfully!",
    });
  } catch (error: any) {
    console.error("Error creating battle:", error);
    res.status(500).json({ error: error.message });
  }
});

// DELETE Squadron - Requires full authentication with session
router.delete("/api/gaming/squadrons/:id", requireAuthentication, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const userHandle = req.user?.handle || req.user?.userHandle;
    
    if (!userHandle) {
      return res.status(401).json({ error: "Not authenticated" });
    }

    const { id } = req.params;

    // Look up or auto-create gaming_players record
    let player = await db.query.gamingPlayers.findFirst({
      where: eq(gamingPlayers.user_handle, userHandle),
    });

    if (!player) {
      console.log("ðŸ‘¤ [SQUADRON] Auto-creating gaming player for:", userHandle);
      const walletAddress = req.user?.walletAddress || "unknown";
      const playerData = {
        user_handle: userHandle,
        wallet_address: walletAddress,
        chain: "xrpl",
        player_name: userHandle
      };
      const [newPlayer] = await db.insert(gamingPlayers).values(playerData as any as any).returning();
      player = newPlayer;
      console.log("âœ… [SQUADRON] Created gaming player:", player.id);
    }

    const squadron = await db.query.squadrons.findFirst({
      where: and(eq(squadrons.id, id), eq(squadrons.player_id, player.id)),
    });

    if (!squadron) {
      return res.status(404).json({ error: "Squadron not found" });
    }

    if (squadron.in_battle) {
      return res.status(400).json({ error: "Cannot delete squadron in battle" });
    }

    await db.delete(squadrons).where(eq(squadrons.id, id));

    res.json({ 
      success: true,
      message: 'Squadron deleted successfully'
    });
  } catch (error: any) {
    console.error("Error deleting squadron:", error);
    res.status(500).json({ error: error.message });
  }
});

export default router;
