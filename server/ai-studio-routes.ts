import { Router, type Request, Response } from "express";
import { db } from "./db";
import { aiGeneratedImages, aiVideoProjects, aiNftCollections } from "../shared/schema";
import { 
  generateAIImage, 
  editAIImage, 
  generateVideoWithSora, 
  calculateVideoPrice,
  generateNFTMetadata 
} from "./openai-service";
import { eq, and, desc } from "drizzle-orm";
import { unifiedStorage } from "./unified-storage";

const router = Router();

// ==================== IMAGE GENERATION ENDPOINTS (FREE) ====================

/**
 * POST /api/ai-studio/generate-image
 * Generate a new image from a text prompt (FREE for users)
 */
router.post("/ai-studio/generate-image", async (req: Request, res: Response) => {
  try {
    const userId = req.body.userId || 'anonymous';
    const { prompt, size, quality, style } = req.body;

    if (!prompt) {
      return res.status(400).json({ error: "Prompt is required" });
    }

    console.log(`üé® [AI Studio] User ${userId} generating image...`);

    // Generate image using OpenAI
    const result = await generateAIImage({
      prompt,
      size: size || "1024x1024",
      quality: quality || "standard",
      style: style || undefined,
    });

    // Upload to storage backend (persistent across deployments)
    const imageBuffer = Buffer.from(result.base64!, 'base64');
    const publicUrl = await unifiedStorage.uploadFile(
      imageBuffer,
      'generated',
      'image/png'
    );

    console.log(`‚úÖ [AI Studio] Image saved to Object Storage: ${publicUrl}`);

    // Save to database
    const [savedImage] = await db.insert(aiGeneratedImages).values({
      user_id: userId,
      prompt,
      output_image_url: publicUrl,
      generation_type: "create",
    } as any).returning();

    res.json({
      success: true,
      image: {
        id: savedImage.id,
        url: publicUrl,
        prompt,
        revisedPrompt: result.revisedPrompt,
      },
    });
  } catch (error: any) {
    console.error("‚ùå [AI Studio] Image generation error:", error);
    res.status(500).json({ error: error.message || "Image generation failed" });
  }
});

/**
 * POST /api/ai-studio/edit-image
 * Edit/upgrade an existing image with a new prompt (FREE for users)
 * Input image is optional - can be used to upgrade existing images
 */
router.post("/ai-studio/edit-image", async (req: Request, res: Response) => {
  try {
    const userId = req.body.userId || 'anonymous';
    const { prompt, inputImageUrl, size, quality } = req.body;

    if (!prompt) {
      return res.status(400).json({ error: "Prompt is required" });
    }

    console.log(`‚úèÔ∏è [AI Studio] User ${userId} editing image...`);

    // Edit/upgrade image using OpenAI
    const result = await editAIImage({
      prompt,
      inputImageUrl: inputImageUrl || undefined,
      size: size || "1024x1024",
      quality: quality || "standard",
    });

    // Upload to storage backend (persistent across deployments)
    const imageBuffer = Buffer.from(result.base64!, 'base64');
    const publicUrl = await unifiedStorage.uploadFile(
      imageBuffer,
      'generated',
      'image/png'
    );

    console.log(`‚úÖ [AI Studio] Edited image saved to Object Storage: ${publicUrl}`);

    // Save to database
    const [savedImage] = await db.insert(aiGeneratedImages).values({
      user_id: userId,
      prompt,
      output_image_url: publicUrl,
      generation_type: "edit",
    } as any).returning();

    res.json({
      success: true,
      image: {
        id: savedImage.id,
        url: publicUrl,
        prompt,
        revisedPrompt: result.revisedPrompt,
      },
    });
  } catch (error: any) {
    console.error("‚ùå [AI Studio] Image editing error:", error);
    res.status(500).json({ error: error.message || "Image editing failed" });
  }
});

/**
 * GET /api/ai-studio/my-images
 * Get all images generated by the current user
 */
router.get("/ai-studio/my-images", async (req: Request, res: Response) => {
  try {
    const userId = req.query.userId as string || 'anonymous';

    const images = await db.query.aiGeneratedImages.findMany({
      where: eq(aiGeneratedImages.user_id, userId),
      orderBy: [desc(aiGeneratedImages.created_at)],
    });

    res.json({ success: true, images });
  } catch (error: any) {
    console.error("‚ùå [AI Studio] Fetch images error:", error);
    res.status(500).json({ error: error.message || "Failed to fetch images" });
  }
});

// ==================== VIDEO GENERATION ENDPOINTS (PAID WITH XRP) ====================

/**
 * POST /api/ai-studio/create-video-project
 * Create a video project with selected images
 * Calculates pricing: 10 images = 1 XRP, 100 images = 9 XRP
 */
router.post("/ai-studio/create-video-project", async (req: Request, res: Response) => {
  try {
    const userId = req.body.userId || 'anonymous';
    const { projectName, description, videoPrompt, imageIds } = req.body;

    if (!projectName || !videoPrompt || !imageIds || imageIds.length === 0) {
      return res.status(400).json({ 
        error: "Project name, video prompt, and at least one image are required" 
      });
    }

    if (imageIds.length > 100) {
      return res.status(400).json({ 
        error: "Maximum 100 images allowed per video" 
      });
    }

    console.log(`üé¨ [AI Studio] User ${userId} creating video project with ${imageIds.length} images...`);

    // Calculate price
    const priceXRP = calculateVideoPrice(imageIds.length);

    // Create video project
    const [project] = await db.insert(aiVideoProjects).values({
      user_id: userId,
      project_name: projectName,
      video_prompt: videoPrompt,
      total_images: imageIds.length,
      price_xrp: priceXRP.toString(),
    }).returning();

    res.json({
      success: true,
      project: {
        id: project.id,
        name: projectName,
        imageCount: imageIds.length,
        priceXRP,
        status: "draft",
      },
    });
  } catch (error: any) {
    console.error("‚ùå [AI Studio] Create video project error:", error);
    res.status(500).json({ error: error.message || "Failed to create video project" });
  }
});

/**
 * POST /api/ai-studio/generate-video
 * Generate video using Sora (when API available)
 * Requires payment confirmation
 */
router.post("/ai-studio/generate-video", async (req: Request, res: Response) => {
  try {
    const { projectId, paymentTxHash } = req.body;

    if (!projectId || !paymentTxHash) {
      return res.status(400).json({ 
        error: "Project ID and payment transaction hash are required" 
      });
    }

    // Get project
    const project = await db.query.aiVideoProjects.findFirst({
      where: eq(aiVideoProjects.id, projectId),
    });

    if (!project) {
      return res.status(404).json({ error: "Project not found" });
    }

    // Verify payment (simplified - should verify on XRPL)
    console.log(`üí≥ [AI Studio] Verifying payment ${paymentTxHash} for project ${projectId}...`);

    // Update payment status (remove invalid fields)
    await db.update(aiVideoProjects)
      .set({  
        // Fields removed: payment_status, payment_tx_hash, status, processing_started_at
        // Only update with valid schema fields if any exist
       } as any)
      .where(eq(aiVideoProjects.id, projectId));

    // Get all images for the video
    const images = await db.query.aiGeneratedImages.findMany({
      where: eq(aiGeneratedImages.user_id, project.user_id),
    });

    const imageUrls = (project.image_ids as number[]).map(id => {
      const img = images.find(i => i.id === id);
      return img ? img.output_image_url : '';
    }).filter(Boolean);

    try {
      // Attempt to generate video with Sora
      const videoResult = await generateVideoWithSora({
        prompt: project.video_prompt,
        images: imageUrls,
        duration: 10,
        resolution: "1080p",
      });

      // Update project with video URL
      await db.update(aiVideoProjects)
        .set({  
          // status, video_url, video_duration, video_format, completed_at removed - not in schema
         } as any)
        .where(eq(aiVideoProjects.id, projectId));

      res.json({
        success: true,
        video: {
          url: videoResult.videoUrl,
          duration: videoResult.duration,
        },
      });
    } catch (soraError: any) {
      // Sora API not available yet - save project for future processing
      await db.update(aiVideoProjects)
        .set({  
          // status and error_message fields removed - not in schema
         } as any)
        .where(eq(aiVideoProjects.id, projectId));

      res.json({
        success: false,
        message: "Video project created successfully. Sora API is coming soon - your video will be generated once the API is available.",
        project: {
          id: projectId,
          status: "pending_api",
          paid: true,
        },
      });
    }
  } catch (error: any) {
    console.error("‚ùå [AI Studio] Video generation error:", error);
    res.status(500).json({ error: error.message || "Video generation failed" });
  }
});

/**
 * GET /api/ai-studio/my-video-projects
 * Get all video projects by the current user
 */
router.get("/ai-studio/my-video-projects", async (req: Request, res: Response) => {
  try {
    const userId = req.query.userId as string || 'anonymous';

    const projects = await db.query.aiVideoProjects.findMany({
      where: eq(aiVideoProjects.user_id, userId),
      orderBy: [desc(aiVideoProjects.created_at)],
    });

    res.json({ success: true, projects });
  } catch (error: any) {
    console.error("‚ùå [AI Studio] Fetch video projects error:", error);
    res.status(500).json({ error: error.message || "Failed to fetch video projects" });
  }
});

// ==================== NFT CONVERSION ENDPOINTS ====================

/**
 * POST /api/ai-studio/generate-nft-metadata
 * Generate NFT metadata for an image or video
 */
router.post("/ai-studio/generate-nft-metadata", async (req: Request, res: Response) => {
  try {
    const { sourceType, sourceId, collectionName, collectionDescription } = req.body;

    if (!sourceType || !sourceId || !collectionName) {
      return res.status(400).json({ 
        error: "Source type, source ID, and collection name are required" 
      });
    }

    let imageUrl = "";
    let metadata: any;

    if (sourceType === "image") {
      const image = await db.query.aiGeneratedImages.findFirst({
        where: eq(aiGeneratedImages.id, sourceId),
      });

      if (!image) {
        return res.status(404).json({ error: "Image not found" });
      }

      imageUrl = image.output_image_url;
      metadata = await generateNFTMetadata({
        name: collectionName,
        description: collectionDescription || image.prompt,
        imageUrl,
        attributes: {
          "Generation Type": image.generation_type,
          "Model": image.model,
          "Size": image.size,
        },
      });
    } else if (sourceType === "video") {
      const video = await db.query.aiVideoProjects.findFirst({
        where: eq(aiVideoProjects.id, sourceId),
      });

      if (!video) {
        return res.status(404).json({ error: "Video not found" });
      }

      imageUrl = video.video_url || "";
      metadata = await generateNFTMetadata({
        name: collectionName,
        description: collectionDescription || video.video_prompt,
        imageUrl,
        attributes: {
          "Type": "AI Generated Video",
          "Duration": `${video.video_duration}s`,
          "Images Count": video.image_count,
        },
      });
    } else {
      return res.status(400).json({ error: "Invalid source type" });
    }

    res.json({
      success: true,
      metadata,
    });
  } catch (error: any) {
    console.error("‚ùå [AI Studio] Generate NFT metadata error:", error);
    res.status(500).json({ error: error.message || "Failed to generate NFT metadata" });
  }
});

/**
 * POST /api/ai-studio/create-nft-collection
 * Create an NFT collection from an image or video
 * This will integrate with devtools for project creation
 */
router.post("/ai-studio/create-nft-collection", async (req: Request, res: Response) => {
  try {
    const userId = req.body.userId || 'anonymous';
    const { 
      sourceType, 
      sourceId, 
      collectionName, 
      collectionDescription, 
      collectionSymbol,
      chain 
    } = req.body;

    if (!sourceType || !sourceId || !collectionName) {
      return res.status(400).json({ 
        error: "Source type, source ID, and collection name are required" 
      });
    }

    console.log(`üé® [AI Studio] Creating NFT collection: ${collectionName}`);

    // Create NFT collection record
    const [nftCollection] = await db.insert(aiNftCollections).values({
      user_id: userId,
      collection_name: collectionName,
      source_type: sourceType,
      source_id: sourceId,
    } as any).returning();

    res.json({
      success: true,
      collection: {
        id: nftCollection.id,
        name: collectionName,
        status: "draft",
        message: "NFT collection created. Ready to integrate with DevTools for minting.",
      },
    });
  } catch (error: any) {
    console.error("‚ùå [AI Studio] Create NFT collection error:", error);
    res.status(500).json({ error: error.message || "Failed to create NFT collection" });
  }
});

export default router;
