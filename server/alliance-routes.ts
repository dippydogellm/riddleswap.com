import express, { Request, Response } from 'express';
import { db } from './db.js';
import { 
  gamingAlliances, 
  allianceMembers, 
  allianceJoinRequests,
  gamingPlayers
} from '../shared/schema.js';
import { eq, and, desc, sql } from 'drizzle-orm';
import crypto from 'crypto';
import { requireAuthentication, AuthenticatedRequest } from './middleware/session-auth';
import { csrfProtection, getCsrfToken } from './middleware/csrf-protection';

const router = express.Router();

// CSRF protection applied individually to state-changing routes (POST/PUT/DELETE)
// GET requests skip CSRF automatically in middleware

// Get CSRF token endpoint
router.get('/csrf-token', requireAuthentication, getCsrfToken);

// Create a new alliance
router.post('/alliances', requireAuthentication, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { name, tag, description, motto, alliance_type } = req.body;
    const userHandle = req.user?.handle || req.user?.userHandle;

    if (!userHandle) {
      console.error('‚ùå [ALLIANCE CREATE] No user handle in request');
      return res.status(401).json({ error: 'Not authenticated' });
    }
    
    console.log('‚úÖ [ALLIANCE CREATE] Creating alliance:', { name, tag, userHandle });

    // Validate required fields
    if (!name || name.trim().length === 0) {
      return res.status(400).json({ error: 'Alliance name is required' });
    }

    if (!tag || tag.trim().length === 0) {
      return res.status(400).json({ error: 'Alliance tag is required' });
    }

    // Validate tag format (3-5 uppercase letters)
    const tagUpper = tag.toUpperCase();
    if (tagUpper.length < 3 || tagUpper.length > 5) {
      return res.status(400).json({ error: 'Alliance tag must be 3-5 characters long' });
    }

    if (!/^[A-Z]+$/.test(tagUpper)) {
      return res.status(400).json({ error: 'Alliance tag must contain only letters (A-Z)' });
    }

    // Check if player is already in an alliance
    const existingMembership = await db.query.allianceMembers.findFirst({
      where: eq(allianceMembers.player_handle, userHandle)
    });

    if (existingMembership) {
      return res.status(400).json({ error: 'You are already in an alliance. Leave your current alliance first.' });
    }

    // Check if tag is already taken (case-insensitive)
    const existingTag = await db.query.gamingAlliances.findFirst({
      where: eq(gamingAlliances.tag, tagUpper)
    });

    if (existingTag) {
      return res.status(400).json({ error: 'Alliance tag is already taken' });
    }

    // Create alliance - id, created_at, updated_at auto-generated by schema
    const allianceData = {
      name: name.trim(),
      tag: tagUpper, // Store tag in uppercase
      description: description?.trim() || null,
      motto: motto?.trim() || null,
      leader_handle: userHandle,
      alliance_type: alliance_type || 'general',
      current_members: 1
    };
    const [insertedAlliance] = await db.insert(gamingAlliances).values(allianceData as any as any).returning();

    // Add creator as leader member - id, created_at, updated_at auto-generated by schema
    const memberData = {
      alliance_id: insertedAlliance.id,
      player_handle: userHandle,
      role: 'leader',
      permissions: {
        can_invite: true,
        can_kick: true,
        can_manage_treasury: true,
        can_start_wars: true
      }
    };
    const [insertedMember] = await db.insert(allianceMembers).values(memberData as any as any).returning();

    // Return complete alliance data for frontend display - consistent format
    res.status(201).json({ 
      success: true,
      message: 'Alliance created successfully',
      alliance: {
        ...insertedAlliance,
        total_power: insertedAlliance.total_power || 0,
        members: [{
          id: insertedMember.id,
          alliance_id: insertedMember.alliance_id,
          player_handle: insertedMember.player_handle,
          role: insertedMember.role,
          permissions: insertedMember.permissions,
          joined_at: insertedMember.joined_at,
          created_at: insertedMember.created_at,
          updated_at: insertedMember.updated_at
        }]
      }
    });
  } catch (error: any) {
    console.error('Error creating alliance:', error);
    res.status(500).json({ error: 'Failed to create alliance', details: error.message });
  }
});

// Get player's current alliance membership
router.get('/alliances/player', requireAuthentication, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const userHandle = req.user?.handle || req.user?.userHandle;

    if (!userHandle) {
      console.error('‚ùå [ALLIANCE PLAYER] No user handle in request');
      return res.status(401).json({ error: 'Not authenticated' });
    }
    
    console.log('‚úÖ [ALLIANCE PLAYER] Fetching alliance for:', userHandle);

    // Find player's alliance membership
    const membership = await db.query.allianceMembers.findFirst({
      where: eq(allianceMembers.player_handle, userHandle)
    });

    if (!membership) {
      return res.json({ 
        success: true,
        alliance: null,
        membership: null,
        message: 'Player is not in an alliance' 
      });
    }

    // Get full alliance details
    const alliance = await db.query.gamingAlliances.findFirst({
      where: eq(gamingAlliances.id, membership.alliance_id)
    });

    // Get all alliance members
    const members = await db.query.allianceMembers.findMany({
      where: eq(allianceMembers.alliance_id, membership.alliance_id)
    });

    res.json({
      success: true,
      alliance: {
        ...alliance,
        members,
        player_role: membership.role,
        player_permissions: membership.permissions,
      },
      membership
    });
  } catch (error: any) {
    console.error('Error fetching player alliance:', error);
    res.status(500).json({ error: 'Failed to fetch player alliance', details: error.message });
  }
});

// List all alliances (public endpoint - no auth required)
router.get('/alliances', async (req: Request, res: Response) => {
  try {
    console.log('üîç [ALLIANCE LIST] Fetching alliances');
    const { search, alliance_type, recruiting_only } = req.query;

    let query = db.select().from(gamingAlliances);
    let conditions: any[] = [];

    if (alliance_type && alliance_type !== 'all') {
      conditions.push(eq(gamingAlliances.alliance_type, alliance_type as string));
    }

    if (recruiting_only === 'true') {
      conditions.push(eq(gamingAlliances.is_recruiting, true));
    }

    if (search) {
      conditions.push(
        sql`${gamingAlliances.name} ILIKE ${`%${search}%`} OR ${gamingAlliances.tag} ILIKE ${`%${search}%`}`
      );
    }

    const alliances = await query
      .where(conditions.length > 0 ? and(...conditions) : undefined)
      .orderBy(desc(gamingAlliances.total_power))
      .limit(100);

    res.json({ 
      success: true,
      alliances,
      count: alliances.length
    });
  } catch (error: any) {
    console.error('Error fetching alliances:', error);
    res.status(500).json({ error: 'Failed to fetch alliances', details: error.message });
  }
});

// Get alliance details with members (public endpoint - no auth required)
router.get('/alliances/:id', async (req: Request, res: Response) => {
  try {
    console.log('üîç [ALLIANCE DETAILS] Fetching alliance:', req.params.id);
    const { id } = req.params;

    const alliance = await db.query.gamingAlliances.findFirst({
      where: eq(gamingAlliances.id, id)
    });

    if (!alliance) {
      return res.status(404).json({ error: 'Alliance not found' });
    }

    const members = await db.query.allianceMembers.findMany({
      where: eq(allianceMembers.alliance_id, id)
    });

    res.json({ 
      success: true,
      alliance: {
        ...alliance,
        members
      }
    });
  } catch (error: any) {
    console.error('Error fetching alliance:', error);
    res.status(500).json({ error: 'Failed to fetch alliance', details: error.message });
  }
});

// Update alliance settings (leader only)
router.put('/alliances/:id', requireAuthentication, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { id } = req.params;
    const { description, motto, is_recruiting, join_requirements } = req.body;
    const userHandle = req.user?.handle || req.user?.userHandle;

    if (!userHandle) {
      return res.status(401).json({ error: 'Not authenticated' });
    }

    const alliance = await db.query.gamingAlliances.findFirst({
      where: eq(gamingAlliances.id, id)
    });

    if (!alliance) {
      return res.status(404).json({ error: 'Alliance not found' });
    }

    if (alliance.leader_handle !== userHandle) {
      return res.status(403).json({ error: 'Only the alliance leader can update settings' });
    }

    const updates: any = { updated_at: new Date() };
    if (description !== undefined) updates.description = description;
    if (motto !== undefined) updates.motto = motto;
    if (is_recruiting !== undefined) updates.is_recruiting = is_recruiting;
    if (join_requirements !== undefined) updates.join_requirements = join_requirements;

    await db.update(gamingAlliances)
      .set(updates)
      .where(eq(gamingAlliances.id, id));

    res.json({ success: true, message: 'Alliance updated successfully' });
  } catch (error: any) {
    console.error('Error updating alliance:', error);
    res.status(500).json({ error: 'Failed to update alliance', details: error.message });
  }
});

// Request to join alliance
router.post('/alliances/:id/join', requireAuthentication, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { id } = req.params;
    const { message } = req.body;
    const userHandle = req.user?.handle || req.user?.userHandle;

    if (!userHandle) {
      console.error('‚ùå [ALLIANCE JOIN] No user handle in request');
      return res.status(401).json({ error: 'Not authenticated' });
    }
    
    console.log('‚úÖ [ALLIANCE JOIN] Request to join:', { allianceId: id, userHandle });

    const alliance = await db.query.gamingAlliances.findFirst({
      where: eq(gamingAlliances.id, id)
    });

    if (!alliance) {
      return res.status(404).json({ error: 'Alliance not found' });
    }

    // Check if player is in another alliance (enforced by unique constraint)
    const otherMembership = await db.query.allianceMembers.findFirst({
      where: eq(allianceMembers.player_handle, userHandle)
    });

    if (otherMembership) {
      return res.status(400).json({ error: 'You are already in an alliance. Leave it first.' });
    }

    // Check if already has pending request
    const existingRequest = await db.query.allianceJoinRequests.findFirst({
      where: and(
        eq(allianceJoinRequests.alliance_id, id),
        eq(allianceJoinRequests.player_handle, userHandle),
        eq(allianceJoinRequests.status, 'pending')
      )
    });

    if (existingRequest) {
      return res.status(400).json({ error: 'You already have a pending request to this alliance' });
    }

    // Enforce join requirements (min_power, min_level)
    if (alliance.join_requirements) {
      const requirements = alliance.join_requirements as any;
      
      // Get player stats to check requirements
      const player = await db.query.gamingPlayers.findFirst({
        where: eq(gamingPlayers.user_handle, userHandle)
      });

      if (requirements.min_power && player) {
        const playerPower = (player.total_power_level || 0);
        if (playerPower < requirements.min_power) {
          return res.status(403).json({ 
            error: `You need at least ${requirements.min_power} total power to join this alliance. Your power: ${playerPower}` 
          });
        }
      }

      if (requirements.min_level && player) {
        // gaming_rank is text (Novice, Warrior, Commander, Lord, Legend)
        // For now, skip level check or convert rank to numeric
        // We'll implement this when we have a proper level system
        console.log(`[ALLIANCE] Level requirement check skipped - player rank: ${player.gaming_rank}`);
      }
      
      // If application required, create join request - id auto-generated by schema
      if (requirements.application_required !== false) {
        const requestData = {
          alliance_id: id,
          player_handle: userHandle,
          message: message || null,
          status: 'pending'
        };
        await db.insert(allianceJoinRequests).values(requestData as any as any);

        return res.json({ 
          success: true, 
          message: 'Join request submitted. Waiting for approval.' 
        });
      }
    }

    // Auto-join with atomic capacity enforcement
    await db.transaction(async (tx) => {
      // Atomically increment if capacity available
      const result = await tx.update(gamingAlliances)
        .set({ 
          current_members: sql`${gamingAlliances.current_members} + 1`,
          updated_at: new Date()
        } as any)
        .where(and(
          eq(gamingAlliances.id, id),
          sql`${gamingAlliances.current_members} < COALESCE(${gamingAlliances.max_members}, 20)`
        ))
        .returning({ current_members: gamingAlliances.current_members });

      // Check if update succeeded (capacity was available)
      if (!result || result.length === 0) {
        throw new Error('Alliance is full');
      }

      // Insert member (only reaches here if capacity was available) - id auto-generated by schema
      const memberData = {
        alliance_id: id,
        player_handle: userHandle,
        role: 'member',
        permissions: {}
      };
      await tx.insert(allianceMembers).values(memberData as any as any);
    });

    res.json({ success: true, message: 'Joined alliance successfully' });
  } catch (error: any) {
    console.error('Error joining alliance:', error);
    const errorMsg = error.message || 'Failed to join alliance';
    const statusCode = error.message === 'Alliance is full' ? 409 : 500;
    res.status(statusCode).json({ error: errorMsg, details: error.message });
  }
});

// Approve join request (leader/officer only)
router.post('/alliances/:id/requests/:requestId/approve', requireAuthentication, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { id, requestId } = req.params;
    const userHandle = req.user?.handle || req.user?.userHandle;

    if (!userHandle) {
      return res.status(401).json({ error: 'Not authenticated' });
    }

    // Check if user has permission to approve
    const userMembership = await db.query.allianceMembers.findFirst({
      where: and(
        eq(allianceMembers.alliance_id, id),
        eq(allianceMembers.player_handle, userHandle)
      )
    });

    if (!userMembership || (userMembership.role !== 'leader' && userMembership.role !== 'officer')) {
      return res.status(403).json({ error: 'Only leaders and officers can approve requests' });
    }

    const request = await db.query.allianceJoinRequests.findFirst({
      where: eq(allianceJoinRequests.id, requestId)
    });

    if (!request || request.status !== 'pending') {
      return res.status(404).json({ error: 'Request not found or already processed' });
    }

    // CRITICAL: Prevent cross-alliance approval vulnerability
    if (request.alliance_id !== id) {
      return res.status(403).json({ error: 'This request is for a different alliance' });
    }

    // Check if player is already in another alliance
    const existingMembership = await db.query.allianceMembers.findFirst({
      where: eq(allianceMembers.player_handle, request.player_handle)
    });

    if (existingMembership) {
      return res.status(400).json({ error: 'Player is already in an alliance' });
    }

    // Use transaction to approve with atomic capacity enforcement
    await db.transaction(async (tx) => {
      // Atomically increment if capacity available
      const result = await tx.update(gamingAlliances)
        .set({ 
          current_members: sql`${gamingAlliances.current_members} + 1`,
          updated_at: new Date()
        } as any)
        .where(and(
          eq(gamingAlliances.id, id),
          sql`${gamingAlliances.current_members} < COALESCE(${gamingAlliances.max_members}, 20)`
        ))
        .returning({ current_members: gamingAlliances.current_members });

      // Check if update succeeded (capacity was available)
      if (!result || result.length === 0) {
        throw new Error('Alliance is full');
      }

      // Add member (only reaches here if capacity was available) - id auto-generated by schema
      const memberData = {
        alliance_id: id,
        player_handle: request.player_handle,
        role: 'member',
        permissions: {}
      };
      await tx.insert(allianceMembers).values(memberData as any as any);

      // Update request status
      await tx.update(allianceJoinRequests)
        .set({ 
          status: 'approved',
          reviewed_by: userHandle,
          reviewed_at: new Date()
        } as any)
        .where(eq(allianceJoinRequests.id, requestId));
    });

    res.json({ success: true, message: 'Member approved and added to alliance' });
  } catch (error: any) {
    console.error('Error approving request:', error);
    const errorMsg = error.message || 'Failed to approve request';
    const statusCode = error.message === 'Alliance is full' ? 409 : 500;
    res.status(statusCode).json({ error: errorMsg, details: error.message });
  }
});

// Leave alliance or kick member
router.delete('/alliances/:id/members/:playerHandle', requireAuthentication, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { id, playerHandle } = req.params;
    const userHandle = req.user?.handle || req.user?.userHandle;

    if (!userHandle) {
      return res.status(401).json({ error: 'Not authenticated' });
    }

    const alliance = await db.query.gamingAlliances.findFirst({
      where: eq(gamingAlliances.id, id)
    });

    if (!alliance) {
      return res.status(404).json({ error: 'Alliance not found' });
    }

    const isLeaving = playerHandle === userHandle;

    // Verify the target member exists
    const targetMembership = await db.query.allianceMembers.findFirst({
      where: and(
        eq(allianceMembers.alliance_id, id),
        eq(allianceMembers.player_handle, playerHandle)
      )
    });

    if (!targetMembership) {
      return res.status(404).json({ error: 'Player is not a member of this alliance' });
    }

    if (!isLeaving) {
      // Kicking - check permissions
      const kickerMembership = await db.query.allianceMembers.findFirst({
        where: and(
          eq(allianceMembers.alliance_id, id),
          eq(allianceMembers.player_handle, userHandle)
        )
      });

      if (!kickerMembership || (kickerMembership.role !== 'leader' && kickerMembership.role !== 'officer')) {
        return res.status(403).json({ error: 'Only leaders and officers can kick members' });
      }

      // Can't kick the leader
      if (playerHandle === alliance.leader_handle) {
        return res.status(403).json({ error: 'Cannot kick the alliance leader' });
      }
    }

    // Use transaction for leave/kick with proper leader succession
    await db.transaction(async (tx) => {
      // If leader is leaving, handle succession
      if (isLeaving && playerHandle === alliance.leader_handle) {
        // Get all other members ordered by officer status and join date
        const remainingMembers = await tx.query.allianceMembers.findMany({
          where: and(
            eq(allianceMembers.alliance_id, id),
            sql`${allianceMembers.player_handle} != ${playerHandle}`
          )
        });

        // If no members remain, delete both leader membership and alliance
        if (remainingMembers.length === 0) {
          // Delete leader's membership first
          await tx.delete(allianceMembers)
            .where(and(
              eq(allianceMembers.alliance_id, id),
              eq(allianceMembers.player_handle, playerHandle)
            ));
          // Then disband alliance (will cascade if configured)
          await tx.delete(gamingAlliances).where(eq(gamingAlliances.id, id));
          return; // No member count update needed - alliance is gone
        }

        // Find successor: highest-ranked officer, or earliest member
        const officers = remainingMembers.filter(m => m.role === 'officer');
        const successor = officers.length > 0 
          ? officers.sort((a, b) => (a.joined_at?.getTime() || 0) - (b.joined_at?.getTime() || 0))[0]
          : remainingMembers.sort((a, b) => (a.joined_at?.getTime() || 0) - (b.joined_at?.getTime() || 0))[0];

        // Transfer leadership
        await tx.update(gamingAlliances)
          .set({ 
            leader_handle: successor.player_handle,
            updated_at: new Date()
          } as any)
          .where(eq(gamingAlliances.id, id));

        // Promote successor to leader
        await tx.update(allianceMembers)
          .set({ 
            role: 'leader',
            permissions: {
              can_invite: true,
              can_kick: true,
              can_manage_treasury: true,
              can_start_wars: true
            },
            updated_at: new Date()
          } as any)
          .where(and(
            eq(allianceMembers.alliance_id, id),
            eq(allianceMembers.player_handle, successor.player_handle)
          ));
      }

      // Remove member with RETURNING to verify deletion
      const deletedMembers = await tx.delete(allianceMembers)
        .where(and(
          eq(allianceMembers.alliance_id, id),
          eq(allianceMembers.player_handle, playerHandle)
        ))
        .returning({ id: allianceMembers.id });

      // Only decrement if member was actually deleted
      if (deletedMembers && deletedMembers.length > 0) {
        await tx.update(gamingAlliances)
          .set({ 
            current_members: sql`GREATEST(0, ${gamingAlliances.current_members} - 1)`,
            updated_at: new Date()
          } as any)
          .where(eq(gamingAlliances.id, id));
      }
    });

    res.json({ 
      success: true, 
      message: isLeaving && playerHandle === alliance.leader_handle 
        ? 'Leadership transferred and you have left the alliance' 
        : isLeaving ? 'Left alliance successfully' : 'Member kicked successfully' 
    });
  } catch (error: any) {
    console.error('Error removing member:', error);
    res.status(500).json({ error: 'Failed to remove member', details: error.message });
  }
});

// Change member role (leader only)
router.put('/alliances/:id/members/:playerHandle/role', requireAuthentication, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { id, playerHandle } = req.params;
    const { role } = req.body;
    const userHandle = req.user?.handle || req.user?.userHandle;

    if (!userHandle) {
      return res.status(401).json({ error: 'Not authenticated' });
    }

    const alliance = await db.query.gamingAlliances.findFirst({
      where: eq(gamingAlliances.id, id)
    });

    if (!alliance) {
      return res.status(404).json({ error: 'Alliance not found' });
    }

    if (alliance.leader_handle !== userHandle) {
      return res.status(403).json({ error: 'Only the leader can change roles' });
    }

    if (!['member', 'officer'].includes(role)) {
      return res.status(400).json({ error: 'Invalid role' });
    }

    const permissions = role === 'officer' ? {
      can_invite: true,
      can_kick: true,
      can_manage_treasury: false,
      can_start_wars: false
    } : {};

    await db.update(allianceMembers)
      .set({ 
        role,
        permissions,
        updated_at: new Date()
      } as any)
      .where(and(
        eq(allianceMembers.alliance_id, id),
        eq(allianceMembers.player_handle, playerHandle)
      ));

    res.json({ success: true, message: 'Role updated successfully' });
  } catch (error: any) {
    console.error('Error updating role:', error);
    res.status(500).json({ error: 'Failed to update role', details: error.message });
  }
});

// Get player's current alliance
router.get('/my-alliance', requireAuthentication, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const userHandle = req.user?.handle || req.user?.userHandle;

    if (!userHandle) {
      console.error('‚ùå [MY ALLIANCE] No user handle in request');
      return res.status(401).json({ error: 'Not authenticated' });
    }
    
    console.log('‚úÖ [MY ALLIANCE] Fetching alliance for:', userHandle);

    const membership = await db.query.allianceMembers.findFirst({
      where: eq(allianceMembers.player_handle, userHandle),
      with: {
        alliance: true
      }
    });

    if (!membership) {
      return res.json({ alliance: null, membership: null });
    }

    // Get all members
    const members = await db.query.allianceMembers.findMany({
      where: eq(allianceMembers.alliance_id, (membership as any).alliance_id)
    });

    res.json({ 
      success: true,
      alliance: {
        ...(membership as any).alliance,
        members
      },
      membership
    });
  } catch (error: any) {
    console.error('Error fetching player alliance:', error);
    res.status(500).json({ error: 'Failed to fetch alliance', details: error.message });
  }
});

// Get pending join requests for an alliance (leader/officer only)
router.get('/alliances/:id/requests', requireAuthentication, async (req: AuthenticatedRequest, res: Response) => {
  try {
    const { id } = req.params;
    const userHandle = req.user?.handle || req.user?.userHandle;

    if (!userHandle) {
      console.error('‚ùå [ALLIANCE REQUESTS] No user handle in request');
      return res.status(401).json({ error: 'Not authenticated' });
    }
    
    console.log('‚úÖ [ALLIANCE REQUESTS] Fetching requests for:', { allianceId: id, userHandle });

    // Check permissions
    const userMembership = await db.query.allianceMembers.findFirst({
      where: and(
        eq(allianceMembers.alliance_id, id),
        eq(allianceMembers.player_handle, userHandle)
      )
    });

    if (!userMembership || (userMembership.role !== 'leader' && userMembership.role !== 'officer')) {
      return res.status(403).json({ error: 'Only leaders and officers can view requests' });
    }

    const requests = await db.query.allianceJoinRequests.findMany({
      where: and(
        eq(allianceJoinRequests.alliance_id, id),
        eq(allianceJoinRequests.status, 'pending')
      )
    });

    res.json({ 
      success: true,
      requests,
      count: requests.length
    });
  } catch (error: any) {
    console.error('Error fetching requests:', error);
    res.status(500).json({ error: 'Failed to fetch requests', details: error.message });
  }
});

export default router;
